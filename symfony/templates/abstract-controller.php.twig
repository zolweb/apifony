{% autoescape false %}
<?php

namespace {{ abstractController.namespace }};

use RuntimeException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Serializer\Encoder\JsonEncoder;
use Symfony\Component\Serializer\SerializerInterface;
use Symfony\Component\Validator\Constraint;
use Symfony\Component\Validator\ConstraintViolationInterface;
use Symfony\Component\Validator\Validator\ValidatorInterface;

abstract class AbstractController
{
    public function __construct(
        protected readonly SerializerInterface $serializer,
        protected readonly ValidatorInterface $validator,
    ) {
    }

{%~ for type in ['string', 'int', 'float', 'bool'] %}
    {%~ for nullable in [false, true] %}
    /**
     * @throws DenormalizationException
     */
    public function get{{ type|capitalize }}{{ nullable ? 'OrNull' : '' }}Parameter(
        Request $request,
        string $name,
        string $in,
        bool $required,
        ?{{ type }} $default = null,
    ): {{ nullable ? '?' : '' }}{{ type }} {
        $bag = match ($in) {
            'query' => $request->query,
            'header' => $request->headers,
            'cookie' => $request->cookies,
            default => throw new RuntimeException('Invalid parameter location.'),
        };

        $isset = $bag->has($name);
        $value = $bag->get($name);

        if (!$isset) {
            if ($required) {
                throw new DenormalizationException("Parameter '$name' in '$in' is required.");
            }

        {%~ if not nullable %}
            if ($default === null) {
                throw new DenormalizationException("Parameter '$name' in '$in' must not be null.");
            }

        {%~ endif %}
            return $default;
        }

        if ($value === null) {
        {%~ if nullable %}
            return null;
        {%~ else %}
            throw new DenormalizationException("Parameter '$name' in '$in' must not be null.");
        {%~ endif %}
        }

        {%~ if type is same as 'string' %}
        return $value;
        {%~ elseif type is same as 'int' %}
        if (!ctype_digit($value)) {
            throw new DenormalizationException("Parameter '$name' in '$in' must be an integer.");
        }

        return intval($value);
        {%~ elseif type is same as 'float' %}
        if (!is_numeric($value)) {
            throw new DenormalizationException("Parameter '$name' in '$in' must be a numeric.");
        }

        return floatval($value);
        {%~ elseif type is same as 'bool' %}
        if (!in_array($value, ['true', 'false'], true)) {
            throw new DenormalizationException("Parameter '$name' in '$in' must be a boolean.");
        }

        return ['true' => true, 'false' => false][$value];
        {%~ endif %}
    }

    {%~ endfor %}
{%~ endfor %}

{%~ for type in ['string', 'int', 'float', 'bool'] %}
    {%~ for nullable in [false, true] %}
    /**
     * @throws DenormalizationException
     */
    public function get{{ type|capitalize }}{{ nullable ? 'OrNull' : '' }}JsonRequestBody(
        Request $request,
        bool $required,
        ?{{ type }} $default = null,
    ): {{ nullable ? '?' : '' }}{{ type }} {
        $value = $request->getContent();

        if ($value === '') {
            if ($required) {
                throw new DenormalizationException('Request body is required.');
            }

    {%~ if not nullable %}
            if ($default === null) {
                throw new DenormalizationException('Request body must not be null.');
            }

    {%~ endif %}
            return $default;
        }

        $value = json_decode($value, true);

        {%~ if nullable and type is not same as 'string' %}
        if ($value === null) {
            return null;
        }

        {%~ endif %}
        {%~ if type is same as 'string' %}
        if (!is_string($value)) {
            throw new DenormalizationException('Request body must be a string.');
        }

        return $value;
        {%~ elseif type is same as 'int' %}
        if (!is_int($value)) {
            throw new DenormalizationException('Request body must be an integer.');
        }

        return $value;
        {%~ elseif type is same as 'float' %}
        if (!is_int($value) && !is_float($value)) {
            throw new DenormalizationException('Request body must be a numeric.');
        }

        return floatval($value);
        {%~ elseif type is same as 'bool' %}
        if (!is_bool($value)) {
            throw new DenormalizationException('Request body must be a boolean.');
        }

        return $value;
        {%~ endif %}
    }

    {%~ endfor %}
{%~ endfor %}
{%~ for nullable in [false, true] %}
    /**
     * @throws DenormalizationException
     */
    public function getObject{{ nullable ? 'OrNull' : '' }}JsonRequestBody(
        Request $request,
        string $class,
        bool $required,
        ?object $default = null,
    ): {{ nullable ? '?' : '' }}object {
        $value = $request->getContent();

        if ($value === '') {
            if ($required) {
                throw new DenormalizationException('Request body is required.');
            }

    {%~ if not nullable %}
            if ($default === null) {
                throw new DenormalizationException('Request body must not be null.');
            }

    {%~ endif %}
            return $default;
        }

    {%~ if nullable %}
        if ($value === 'null') {
            return null;
        }

    {%~ endif %}
        return $this->serializer->deserialize($value, $class, JsonEncoder::FORMAT);
    }

{%~ endfor %}

    /**
     * @param array<Constraint> $constraints
     * @param array<string, array<string, array<string>>> $errors
     */
    public function validateParameter(
        string $name,
        string $in,
        mixed $value,
        array $constraints,
        array& $errors,
    ): void {
        $violations = $this->validator->validate($value, $constraints);

        if (count($violations) > 0) {
            $errors[$in][$name] = array_map(
                fn (ConstraintViolationInterface $violation) => $violation->getMessage(),
                iterator_to_array($violations),
            );
        }
    }

    /**
     * @param array<Constraint> $constraints
     * @param array<string, array<string, array<string>>> $errors
     */
    public function validateRequestBody(
        mixed $value,
        array $constraints,
        array& $errors,
    ): void {
        $violations = $this->validator->validate($value, $constraints);

        if (count($violations) > 0) {
            foreach ($violations as $violation) {
                $errors['requestBody'][$violation->getPropertyPath()][] = $violation->getMessage();
            }
        }
    }
}
{% endautoescape %}